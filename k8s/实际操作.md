太棒了！这是一个绝佳的学习方式。下面我为您设计了一个非常贴近企业实践的、端到端的项目操作流程。

这个项目将部署一个**“访客计数器”Web 应用**，它包含：
1.  **一个 Web 前端**: 用于显示欢迎信息和访客数量。
2.  **一个 Redis 数据库**: 用于存储访客数量。

我们将通过这个项目，串联起您提到的所有核心概念，并且所有组件都非常轻量，适合在配置不高的电脑上运行。

---

### 项目目标与技术栈

| 目标 | 使用的 K8s 资源/工具 |
| :--- | :--- |
| 1. 环境隔离 | `Namespace` |
| 2. 部署 Redis (带持久化) | `Helm`, `PersistentVolumeClaim (PVC)` |
| 3. 安全地存储 Redis 密码 | `Secret` |
| 4. 配置 Web 应用的欢迎语 | `ConfigMap` |
| 5. 部署并管理 Web 应用 | `Deployment` |
| 6. 在集群内部暴露 Web 应用 | `Service (ClusterIP)` |
| 7. 从外部浏览器访问 Web 应用 | `Ingress` |
| 8. 模拟日常运维 | 扩容、更新、排错 |

---

### Phase 0: 环境准备 (本地 K8s 集群)

我们需要一个本地的 K8s 环境。**Minikube** 是最简单、最适合新手的选择。

1.  **安装 Minikube**: 根据你的操作系统，参照官方文档安装：[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
2.  **安装 kubectl**: K8s 的命令行工具：[https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/)
3.  **安装 Helm**: K8s 的包管理器：[https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)

4.  **启动 Minikube 集群**
    *   打开你的终端，执行以下命令：
        ```bash
        # 启动一个包含 ingress 插件的 minikube 集群
        minikube start --addons=ingress
        ```
    *   **效果**: Minikube 会在你的电脑上（通过 Docker 或虚拟机）创建一个单节点的 K8s 集群，并自动配置 `kubectl` 连接到它。`--addons=ingress` 预装了 Ingress 控制器，后面会用到。

---

### Phase 1: 创建项目环境 (Namespace)

企业实践中，第一步总是为项目创建一个独立的命名空间。

1.  **操作**: 创建一个名为 `webapp-prod` 的命名空间。
    ```bash
    kubectl create namespace webapp-prod
    ```
2.  **验证**: 查看是否创建成功。
    ```bash
    kubectl get namespace
    ```
    **效果**: 你会看到 `webapp-prod` 出现在列表中。
3.  **切换上下文 (推荐)**: 为了后续操作方便，我们将当前会话的默认命名空间切换过去。
    ```bash
    kubectl config set-context --current --namespace=webapp-prod
    ```

---

### Phase 2: 部署依赖服务 - Redis (Helm & PVC)

我们将使用 Helm 来快速部署一个带持久化存储的 Redis。这是企业中部署复杂中间件的典型方式。

1.  **添加 Helm 仓库**: Bitnami 提供了大量高质量的 Helm Charts。
    ```bash
    helm repo add bitnami https://charts.bitnami.com/bitnami
    helm repo update
    ```
2.  **安装 Redis**: 我们用 `helm install` 命令来部署。
    *   这里我们通过 `--set` 参数来覆盖一些默认配置：
        *   `auth.password`: 设置 Redis 密码。
        *   `master.persistence.enabled=true`: 开启持久化。
        *   `master.persistence.size=1Gi`: 申请 1G 的存储空间。
    ```bash
    # 为了后续引用，我们将密码设置为 my-redis-password
    helm install redis bitnami/redis \
      --set auth.password=my-redis-password \
      --set master.persistence.enabled=true \
      --set master.persistence.size=1Gi
    ```
3.  **验证与体验**:
    *   **查看 Helm Release**:
        ```bash
        helm list
        ```
        **效果**: 你会看到一个名为 `redis` 的 Release，状态为 `deployed`。
    *   **查看 Pod**:
        ```bash
        kubectl get pods
        ```
        **效果**: 你会看到一个名为 `redis-master-0` 的 Pod 正在启动（可能需要一两分钟变为 `Running`）。
    *   **体验 PVC**:
        ```bash
        kubectl get pvc
        ```
        **效果**: 你会看到一个名为 `redis-data-redis-master-0` 的 `PersistentVolumeClaim`，状态为 `Bound`。这说明 Helm 自动为我们创建了 PVC，并且 K8s 已经为它绑定了后端存储。**你已经成功使用了 PVC！**

---

### Phase 3: 创建应用配置 (ConfigMap & Secret)

现在为我们的 Web 应用准备配置和密钥。

1.  **创建 Secret**: 存储上面我们设置的 Redis 密码。
    *   首先，手动对密码进行 Base64 编码（在 K8s YAML 中，Secret 的值必须是 Base64 编码的）。
        ```bash
        # 在 macOS 或 Linux 上
        echo -n 'my-redis-password' | base64
        # 输出应为: bXktcmVkaXUtcGFzc3dvcmQ=
        ```
    *   创建一个名为 `secret.yaml` 的文件，内容如下：
        ```yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: webapp-secret
        type: Opaque
        data:
          # key 是 REDIS_PASSWORD, value 是上面 base64 编码后的密码
          REDIS_PASSWORD: bXktcmVkaXUtcGFzc3dvcmQ=
        ```
    *   应用它：
        ```bash
        kubectl apply -f secret.yaml
        ```

2.  **创建 ConfigMap**: 存储 Web 应用的欢迎语。
    *   创建一个名为 `configmap.yaml` 的文件，内容如下：
        ```yaml
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: webapp-config
        data:
          WELCOME_MESSAGE: "Hello from Kubernetes! Visitors:"
        ```
    *   应用它：
        ```bash
        kubectl apply -f configmap.yaml
        ```

---

### Phase 4: 部署 Web 应用 (Deployment & Service)

现在，部署我们的核心应用。

1.  **创建 Deployment**:
    *   创建一个名为 `deployment.yaml` 的文件。这个文件定义了如何运行我们的 Web 应用。
    *   **注意**: `envFrom` 部分将 `ConfigMap` 和 `Secret` 注入为环境变量。`REDIS_HOST` 直接指向 Redis 的 Service 名称 `redis-master`。
        ```yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: visitor-app
        spec:
          replicas: 2 # 部署两个副本，体验负载均衡
          selector:
            matchLabels:
              app: visitor-app
          template:
            metadata:
              labels:
                app: visitor-app
            spec:
              containers:
              - name: app
                # 我们使用一个公开的、专门用于此演示的镜像
                image: gcr.io/google-samples/gb-frontend:v4
                ports:
                - containerPort: 80
                env:
                - name: REDIS_HOST
                  # 这是 Helm 部署的 Redis Master Service 的默认名称
                  value: "redis-master"
                envFrom:
                - configMapRef:
                    name: webapp-config
                - secretRef:
                    name: webapp-secret
        ```
    *   应用它：
        ```bash
        kubectl apply -f deployment.yaml
        ```

2.  **创建 Service**: 为上面的 Deployment 创建一个集群内部的访问入口。
    *   创建一个名为 `service.yaml` 的文件：
        ```yaml
        apiVersion: v1
        kind: Service
        metadata:
          name: visitor-app-svc
        spec:
          type: ClusterIP # 只在集群内部可见
          selector:
            app: visitor-app # 这必须和 Deployment template 的 label 匹配
          ports:
          - protocol: TCP
            port: 80 # Service 暴露的端口
            targetPort: 80 # Pod 容器的端口
        ```
    *   应用它：
        ```bash
        kubectl apply -f service.yaml
        ```

3.  **验证**:
    ```bash
    kubectl get deployment,service,pods
    ```
    **效果**: 你应该能看到 `visitor-app` 这个 Deployment，两个 `visitor-app-xxx` Pod，以及 `visitor-app-svc` 这个 Service。

---

### Phase 5: 暴露应用到外部 (Ingress)

现在，让我们通过 Ingress 将应用暴露给浏览器访问。

1.  **创建 Ingress**:
    *   创建一个名为 `ingress.yaml` 的文件：
        ```yaml
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: visitor-app-ingress
        spec:
          rules:
          - host: "visitor.app.test" # 我们虚构一个域名
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: visitor-app-svc # 指向我们创建的 Service
                    port:
                      number: 80
        ```
    *   应用它：
        ```bash
        kubectl apply -f ingress.yaml
        ```

2.  **访问应用**:
    *   **获取 IP 地址**: Minikube 有一个特殊的命令来获取 Ingress Controller 的 IP。
        ```bash
        minikube ip
        # 假设输出是 192.168.49.2
        ```
    *   **修改 hosts 文件**: 我们需要将我们虚构的域名 `visitor.app.test` 指向这个 IP。
        *   **macOS/Linux**: `sudo nano /etc/hosts`
        *   **Windows**: 以管理员身份打开记事本，编辑 `C:\Windows\System32\drivers\etc\hosts`
        *   在文件末尾添加一行：
            ```
            192.168.49.2  visitor.app.test  # 使用你自己的 minikube ip
            ```
        *   保存文件。
    *   **测试**: 打开浏览器，访问 `http://visitor.app.test`。
        **效果**: 你应该能看到页面显示 "Hello from Kubernetes! Visitors:"，并且每次刷新，数字都会增加！

**恭喜你！你已经完成了一个端到端的 K8s 应用部署！**

---

### Phase 6: 模拟日常运维 (扩容、更新、排错)

1.  **扩容 (Scale Up)**: 假设流量高峰来了，我们需要增加 Web 应用的副本。
    ```bash
    kubectl scale deployment visitor-app --replicas=4
    kubectl get pods
    ```
    **效果**: 你会看到 `visitor-app` 的 Pod 数量很快从 2 个变成了 4 个。Ingress 会自动将流量负载均衡到这 4 个 Pod。

2.  **更新配置 (Rolling Update)**: 让我们修改欢迎语。
    *   编辑 `configmap.yaml` 文件，将 `WELCOME_MESSAGE` 改为 `Welcome to My Awesome K8s App! Visitors:`。
    *   应用新的 ConfigMap：
        ```bash
        kubectl apply -f configmap.yaml
        ```
    *   **重要**: ConfigMap 更新后，默认不会触发 Pod 重启。我们需要手动触发一次滚动更新来加载新配置。最简单的方式是给 Deployment 加一个无关紧要的注解。
        ```bash
        kubectl patch deployment visitor-app -p \
          "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"restarted-at\":\"$(date +%s)\"}}}}}"
        ```
    *   观察滚动更新过程：
        ```bash
        kubectl get pods -w # -w 表示 watch, 持续观察
        ```
        **效果**: 你会看到 K8s 逐个创建新的 Pod，并销毁旧的 Pod。更新完成后，刷新浏览器，你会看到新的欢迎语！

3.  **排错 (Debugging)**: 假设一个 Pod 出了问题。
    *   **查看日志**:
        ```bash
        # 首先获取一个 Pod 的全名
        POD_NAME=$(kubectl get pods -l app=visitor-app -o jsonpath='{.items[0].metadata.name}')
        # 查看它的日志
        kubectl logs $POD_NAME
        ```
    *   **进入容器**:
        ```bash
        kubectl exec -it $POD_NAME -- /bin/sh
        ```
        **效果**: 你会进入到容器的 shell 内部，可以在里面执行 `ls`, `ping redis-master` 等命令来诊断问题。

---

### Phase 7: 清理资源 (非常重要！)

体验完毕后，我们需要清理所有创建的资源，释放电脑性能。

1.  **删除项目所有资源**: 最快的方式是直接删除命名空间。
    ```bash
    kubectl delete namespace webapp-prod
    ```
    **效果**: K8s 会自动删除该命名空间下的所有资源（Deployment, Service, Pods, Ingress, PVC, Secret, ConfigMap...）。这个过程可能需要一点时间。

2.  **删除 Helm Release**: (虽然上一步已经删除了，但了解一下 Helm 的卸载命令)
    ```bash
    helm uninstall redis -n webapp-prod
    ```
    *注意：此时 `webapp-prod` 已不存在，此命令会报错，仅作演示。*

3.  **停止/删除 Minikube 集群**:
    *   如果你只是想暂时关闭，节省资源：
        ```bash
        minikube stop
        ```
    *   如果你想彻底删除集群，释放所有磁盘空间：
        ```bash
        minikube delete --all
        ```

这个流程覆盖了从环境准备到部署、运维、清理的全过程，并且让你亲手实践了所有核心概念。希望对你的学习有巨大帮助！




好的，非常抱歉之前的镜像地址给您带来了困扰。这种情况确实时有发生，因为公共镜像的维护状态会随时间变化。

为了确保这次一定成功，我们切换到一个更简单、更稳定、且绝对不会出错的镜像：**Nginx**。

我们将稍微修改一下项目目标：不再是访客计数器，而是一个可以**动态显示欢迎信息的 Nginx 欢迎页**。这个项目同样能覆盖到所有核心的 K8s 操作，而且更加轻量和稳定。

---

### 项目目标 (修订版)

我们将部署一个定制的 Nginx 服务：
1.  **一个定制的 Nginx Pod**：它会从 `ConfigMap` 读取欢迎语，并将其展示在默认的欢迎页面上。
2.  **一个 Redis 服务**: 我们保留它，因为部署它的流程（`Helm` + `PVC`）对您的学习体验非常有价值。虽然 Nginx 不会直接使用它，但在一个“项目”中同时管理数据库和应用是很常见的场景。

---

### 解决方案：使用一个稳定且可定制的 Nginx 镜像

我们将使用官方的 `nginx` 镜像，并通过一个巧妙的方法（结合 `ConfigMap` 和启动命令）来动态生成首页。

#### 第一步：清理旧的、有问题的 Deployment

在应用新的配置之前，最好先清理掉之前失败的 `Deployment`，避免混淆。

```bash
kubectl delete deployment visitor-app
```
(如果您之前还创建了 `Service` 和 `Ingress`，也可以一并删除，我们稍后会重新创建它们)
```bash
kubectl delete service visitor-app-svc
kubectl delete ingress visitor-app-ingress
```

#### 第二步：修改 `ConfigMap` 和 `Deployment`

1.  **更新 `configmap.yaml`**
    我们将用这个 `ConfigMap` 来存放整个 `index.html` 文件的内容。

    `configmap.yaml`:
    ```yaml
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: webapp-config
    data:
      # 我们将整个 HTML 文件作为 ConfigMap 的一个 key
      index.html: |
        <!DOCTYPE html>
        <html>
        <head>
        <title>Welcome to K8s!</title>
        <style>
          body {
            width: 35em;
            margin: 0 auto;
            font-family: Tahoma, Verdana, Arial, sans-serif;
          }
        </style>
        </head>
        <body>
        <h1>Hello from Kubernetes!</h1>
        <p>This is a custom Nginx page, served via a Kubernetes ConfigMap.</p>
        <p>My Redis password is held securely in a Secret (but I won't show it here!).</p>
        <p><em>Page loaded at: <!--# echo var="date_local" --></em></p>
        </body>
        </html>
    ```
    **应用它**：
    ```bash
    kubectl apply -f configmap.yaml
    ```

2.  **创建新的 `deployment.yaml`**
    这是最关键的修改。我们将：
    *   使用 `nginx:latest` 镜像。
    *   将 `webapp-config` 这个 `ConfigMap` 作为一个 `Volume` (存储卷) 挂载到 Nginx 的 HTML 目录下。
    *   这样，`ConfigMap` 中的 `index.html` 文件就会覆盖掉 Nginx 容器内默认的首页。

    `deployment.yaml`:
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: nginx-welcome-app
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: nginx-welcome
      template:
        metadata:
          labels:
            app: nginx-welcome
        spec:
          containers:
          - name: nginx
            image: nginx:latest # 使用稳定、绝对可用的官方 Nginx 镜像
            ports:
            - containerPort: 80
            volumeMounts: # 步骤3: 将 Volume 挂载到容器内
            - name: html-volume
              mountPath: /usr/share/nginx/html # 这是 Nginx 存放网页文件的目录
              readOnly: true
          volumes: # 步骤2: 定义一个 Volume，它的数据来自 ConfigMap
          - name: html-volume
            configMap:
              name: webapp-config # 步骤1: 引用我们创建的 ConfigMap
    ```
    **应用它**：
    ```bash
    kubectl apply -f deployment.yaml
    ```

#### 第三步：创建新的 `Service` 和 `Ingress`

我们需要更新 `Service` 和 `Ingress`，让它们指向新的 `Deployment`。

1.  **创建 `service.yaml`**
    注意 `selector` 的值要和新 `Deployment` 的标签 (`app: nginx-welcome`) 匹配。

    `service.yaml`:
    ```yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: nginx-app-svc
    spec:
      type: ClusterIP
      selector:
        app: nginx-welcome # 匹配新的 label
      ports:
      - protocol: TCP
        port: 80
        targetPort: 80
    ```
    **应用它**:
    ```bash
    kubectl apply -f service.yaml
    ```

2.  **创建 `ingress.yaml`**
    同样，`backend` 部分要指向新的 `Service`。

    `ingress.yaml`:
    ```yaml
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: nginx-app-ingress
    spec:
      rules:
      - host: "nginx.app.test" # 我们换一个新的域名，避免浏览器缓存
        http:
          paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: nginx-app-svc # 指向新的 Service
                port:
                  number: 80
    ```
    **应用它**:
    ```bash
    kubectl apply -f ingress.yaml
    ```

#### 第四步：验证

1.  **检查 Pod 状态**：
    ```bash
    kubectl get pods
    ```
    这次您应该能看到 `nginx-welcome-app-` 开头的两个 Pod 很快就进入了 `Running` 状态。

2.  **更新 hosts 文件**：
    *   编辑您的 `hosts` 文件 (`/etc/hosts` 或 `C:\Windows\System32\drivers\etc\hosts`)。
    *   将之前添加的域名修改为新的域名 `nginx.app.test` (或者新增一行)：
        ```
        <your-minikube-ip>  nginx.app.test
        ```

3.  **测试**：
    *   打开浏览器，访问 `http://nginx.app.test`。
    *   **效果**：您应该能看到我们刚才在 `ConfigMap` 中定义的那个漂亮的 HTML 欢迎页面！

### 总结这次的调整

这个新方案的优点：

*   **镜像极其稳定**：`nginx` 是 Docker Hub 上下载量最高的镜像之一，永远可用。
*   **覆盖了核心概念**：我们依然用到了 `Deployment`, `Service`, `Ingress`, `ConfigMap`, `Volume`。
*   **体验了 Volume 挂载**：您亲身体验了如何将 `ConfigMap` 作为一个文件卷挂载到 Pod 中，这是 K8s 中一个非常强大和常用的功能。

现在请您按照这个修订后的流程操作，这次的体验一定会非常顺畅。