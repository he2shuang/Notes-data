### 一、核心理念与目标

在深入细节之前，先理解 K8s 的目标是什么：

- **自动化 (Automation)**: 自动部署、扩展和管理容器化的应用程序。
- **声明式 (Declarative)**: 你只需要告诉 K8s 你“想要的状态”（比如：我需要3个Web服务器副本），K8s 会持续工作，确保系统的“实际状态”与你的“期望状态”保持一致。如果一个副本挂了，它会自动再启动一个。
- **弹性和自愈 (Resilience & Self-healing)**: 自动处理节点或容器的故障，重新调度、重启容器，保证服务的高可用性。

### 二、核心概念 (用户需要了解和操作的对象)

这些是你作为开发者或运维人员最常打交道的“资源对象”，就像是你要运送的“集装箱”和“货物清单”。

#### 1. **Pod**

- **是什么**: K8s 中最小、最基本的部署单元。你可以把它想象成一个“豆荚”，里面可以包含一个或多个紧密相关的“豆子”（容器）。
- **作用**:
    - **原子单元**: Pod 是 K8s 调度、扩缩容的基本单位。一个 Pod 要么被完整地调度到一个节点上，要么不被调度。
    - **资源共享**: Pod 内的多个容器共享同一个网络命名空间（IP地址、端口空间）和存储卷 (Volume)。这使得它们可以通过 `localhost` 互相通信，非常适合将主应用和辅助工具（如日志收集器）打包在一起。

#### 2. **Node (节点)**

- **是什么**: 一个工作机器，可以是一台物理服务器，也可以是一台虚拟机。
- **作用**: 它是 K8s 集群的“劳动力”，是实际运行 Pod 的地方。所有 Pod 最终都会被调度到某个 Node 上去执行。

#### 3. **Service (服务)**

- **是什么**: 一个为一组功能相同的 Pod 提供单一、稳定的访问入口的抽象层。
- **作用**:
    - **解决 Pod IP 变化问题**: Pod 是“短暂的”，随时可能被销毁重建，每次重建 IP 地址都会变。Service 提供了一个固定的 IP 地址和 DNS 名称。
    - **服务发现与负载均衡**: 当你访问一个 Service 时，它会自动将请求转发到其后端关联的某个健康的 Pod 上，实现了简单的负载均衡。外部用户或其他内部服务通过访问 Service 来使用应用，而无需关心后端 Pod 的具体位置和数量。

#### 4. **Deployment**

- **是什么**: 一个更高级别的对象，用来管理 Pod 和 ReplicaSet (下面会讲)。
- **作用**:
    - **定义期望状态**: 你在 Deployment 中声明需要运行多少个 Pod 副本、使用哪个容器镜像、更新策略是什么等等。
    - **滚动更新 (Rolling Update)**: 可以平滑地升级应用，逐个替换旧的 Pod，而不会中断服务。
    - **回滚 (Rollback)**: 如果新版本有问题，可以一键回滚到之前的稳定版本。
    - **弹性伸缩**: 可以轻松地增加或减少 Pod 的副本数量。

#### 5. **ReplicaSet**

- **是什么**: Deployment 的底层控制器，它的唯一目标是确保在任何时候都有指定数量的 Pod 副本在运行。
- **作用**: 保证 Pod 的副本数。如果一个 Pod 挂了，ReplicaSet 会立即创建一个新的来替代它。通常你不会直接操作 ReplicaSet，而是通过 Deployment 来间接管理它。

#### 6. **Namespace (命名空间)**

- **是什么**: 将一个物理 K8s 集群划分为多个虚拟的、隔离的集群。
- **作用**:
    - **资源隔离**: 不同 Namespace 下的资源名称可以相同，互不影响。
    - **权限管理**: 可以为不同的用户或团队分配不同 Namespace 的访问权限。
    - **环境划分**: 常用于区分开发（dev）、测试（test）、生产（prod）等不同环境。

#### 7. **Volume (存储卷)**

- **是什么**: 为容器提供持久化存储的机制。
- **作用**: 容器本身的文件系统是临时的，当容器重启时，数据会丢失。Volume 将 Pod 的生命周期与存储的生命周期解耦，即使 Pod 被销毁，Volume 中的数据依然可以保留，并可以被新的 Pod 挂载使用。

#### 8. **ConfigMap & Secret**

- **是什么**: 用于存储配置数据和敏感数据（如密码、API 密钥）的对象。
- **作用**: 将配置和密钥与应用程序代码分离。你可以将它们作为环境变量或文件挂载到 Pod 中，这样修改配置时就无需重新构建容器镜像。Secret 会以 Base64 编码方式存储，提供了比明文更安全的保护。


### 三、K8s 架构与模块 (系统的内部组件)

K8s 集群由两类节点组成：**控制平面 (Control Plane)** 和 **工作节点 (Worker Nodes)**。

#### (A) 控制平面 (Control Plane) - “大脑”

控制平面是集群的决策中心，负责管理整个集群的状态。它通常运行在一组专用的服务器上（以前叫 Master 节点）。

1. **API Server (kube-apiserver)**
    - **作用**: **集群的统一入口**。所有组件（包括用户、控制器、其他节点）之间的通信都必须通过 API Server。它负责：
        - 提供 RESTful API，用于查询和修改集群状态。
        - 处理认证、授权和准入控制。
        - 验证并处理所有请求，然后将结果持久化到 etcd 中。
    - **比喻**: 集群的“总前台”或“中央调度室”，所有指令都从这里下达和接收。
2. **etcd**
    - **作用**: **集群的数据库**。一个高可用的键值存储系统，用于保存整个集群的所有状态数据（比如有哪些 Pod、哪些 Service、它们的配置是什么等等）。
    - **比喻**: 集群的“中央账本”或“大脑记忆区”，记录了所有对象的期望状态和当前状态。它是唯一的数据源，极其重要。
3. **Scheduler (kube-scheduler)**
    - **作用**: **负责Pod的调度**。它会持续监控有没有新创建但尚未分配到 Node 的 Pod。一旦发现，它就会根据一系列算法（如节点资源余量、亲和性/反亲和性策略、污点和容忍等）为这个 Pod 选择一个最合适的 Node。
    - **比喻**: “人力资源分配经理”，负责把新员工（Pod）分配到最合适的工位（Node）上。
4. **Controller Manager (kube-controller-manager)**
    - **作用**: **维护集群状态的“调谐器”**。它内部包含了很多独立的控制器（如 Node Controller, Replication Controller, Deployment Controller 等）。每个控制器负责监视一种特定资源的状态，并努力将当前状态调整到在 etcd 中记录的期望状态。
    - **比喻**: 一群“尽职的经理”，比如“副本数经理”（确保 Pod 数量正确）、“节点经理”（发现节点故障并处理）等，他们不断地巡视，确保一切都按计划运行。

#### (B) 工作节点 (Worker Nodes) - “劳动力”

工作节点是实际运行应用程序容器的地方。

1. **Kubelet**
    - **作用**: **每个 Node 上的“代理”**。它是运行在每个工作节点上的主要组件，负责与控制平面的 API Server 通信。
        - 接收并执行 API Server 发来的指令（比如启动或停止某个 Pod）。
        - 管理在该节点上运行的 Pod 的生命周期。
        - 定期向 API Server 汇报该节点和其上 Pod 的状态。
    - **比喻**: 每个工位上的“工头”，直接听从“中央调度室”（API Server）的命令，管理自己手下的工人（容器）。
2. **Kube-proxy**
    - **作用**: **每个 Node 上的“网络管家”**。它负责维护节点上的网络规则，这些规则允许从集群内部或外部与 Pod 进行网络通信。它实现了 Service 的概念，将访问 Service 的流量转发到正确的后端 Pod。
    - **比喻**: 每个工位上的“内部路由器”或“交通警察”，确保发往某个服务的网络请求能准确找到对应的 Pod。
3. **Container Runtime (容器运行时)**
    - **作用**: **真正运行容器的软件**。Kubelet 通过它来启动、停止和管理容器。常见的容器运行时有 Docker、containerd、CRI-O 等。
    - **比喻**: 汽车的“引擎”。Kubelet 是司机，告诉引擎何时启动、加速或停止，但引擎才是真正让车轮转动的部分。


### 四、工作流程示例：创建一个 Deployment

1. 用户通过 `kubectl` 命令行工具，向 **API Server** 发送一个创建 Deployment 的 YAML 文件。
2. **API Server** 验证请求后，将 Deployment 的信息存入 **etcd**。
3. **Controller Manager** 中的 Deployment 控制器检测到了新的 Deployment 对象，于是它根据定义创建了一个 **ReplicaSet** 对象，并将其信息也存入 **etcd**。
4. ReplicaSet 控制器发现需要创建3个 Pod，于是它创建了3个 Pod 的定义，并存入 **etcd**。
5. **Scheduler** 发现了3个未被调度的 Pod，它为每个 Pod 选择一个最合适的 **Node**，然后更新 Pod 的信息（将 Node 名称写入），并存回 **etcd**。
6. 目标 Node 上的 **Kubelet** 检测到有新的 Pod 被分配给了自己。
7. **Kubelet** 读取 Pod 的配置（比如需要哪个镜像），然后命令 **Container Runtime** 去拉取镜像并启动容器。
8. 同时，所有节点上的 **Kube-proxy** 会更新网络规则，以确保如果这个 Pod 属于某个 Service，流量可以正确地路由到它。
9. **Kubelet** 持续监控 Pod 的状态，并向 **API Server** 汇报，更新 **etcd** 中的状态。

通过这个流程，所有组件协同工作，最终将用户的“期望状态”变为了集群中的“实际状态”。