package com.yugabyte.function;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.microsoft.azure.functions.ExecutionContext;
import com.microsoft.azure.functions.HttpRequestMessage;
import com.microsoft.azure.functions.HttpResponseMessage;
import com.microsoft.azure.functions.HttpStatus;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

import com.yugabyte.function.DatabaseMetadataService.ColumnMetadata;

/**
 * 包含所有 CRUD (创建, 读取, 更新, 删除) 操作核心业务逻辑的处理器类。
 * 该类严重依赖 {@link DatabaseMetadataService} 来动态地适应不同的数据库表结构。
 */
public class CrudHandler {

    private static final Gson gson = new Gson();

    /**
     * 处理 HTTP GET 请求，用于查询和检索记录。
     *
     * @param request 包含请求信息的 {@link HttpRequestMessage} 对象。
     * @param conn    一个活动的数据库连接。
     * @param table   操作的目标表名。
     * @param context Azure Function 的执行上下文。
     * @return 一个包含查询结果的 HTTP 响应。
     * @throws SQLException 如果发生数据库访问错误。
     */
    public HttpResponseMessage handleGet(HttpRequestMessage<Optional<String>> request, Connection conn, String table, ExecutionContext context) throws SQLException {
        Map<String, String> queryParams = request.getQueryParameters();
        
        // 1. 获取表的元数据用于验证
        Map<String, ColumnMetadata> tableColumns = DatabaseMetadataService.getTableColumns(conn, table, context);
        
        // 2. 构建 SQL 语句和 WHERE 子句
        StringBuilder sql = new StringBuilder("SELECT * FROM " + table);
        List<Object> params = new ArrayList<>();
        List<String> whereClauses = new ArrayList<>();

        // 处理查询参数，将查询参数转换为 WHERE 子句
        if (!queryParams.isEmpty()) {
            for (Map.Entry<String, String> entry : queryParams.entrySet()) {
                String key = entry.getKey();
                // 只处理在表中实际存在的列，如果存在其他查询参数，给出提醒
                if (tableColumns.containsKey(key)) {
                    whereClauses.add(key + " = ?");
                    try {
                        // 使用 UUID 转换尝试
                        params.add(UUID.fromString(entry.getValue()));
                    } catch (IllegalArgumentException e) {
                        params.add(entry.getValue());
                    }
                } else {
                    context.getLogger().warning("Ignoring invalid query parameter '" + key + "' as it's not a column in table '" + table + "'.");
                }
            }

            if (!whereClauses.isEmpty()) {
                sql.append(" WHERE ").append(String.join(" AND ", whereClauses));
            }
        }

        context.getLogger().info("Executing GET: " + sql.toString());

        // 3. 执行查询
        try (PreparedStatement pstmt = conn.prepareStatement(sql.toString())) {
            for (int i = 0; i < params.size(); i++) {
                pstmt.setObject(i + 1, params.get(i));
            }

            ResultSet rs = pstmt.executeQuery();
            List<Map<String, Object>> resultList = new ArrayList<>();
            ResultSetMetaData md = rs.getMetaData();
            int columns = md.getColumnCount();
            while (rs.next()) {
                Map<String, Object> row = new HashMap<>();
                for (int i = 1; i <= columns; ++i) {
                    // 对于 jsonb 类型，getObject 可能会返回 PGobject，其 getValue() 方法返回 json 字符串
                    Object obj = rs.getObject(i);
                    if (obj instanceof org.postgresql.util.PGobject && "jsonb".equalsIgnoreCase(((org.postgresql.util.PGobject) obj).getType())) {
                        // 使用 Gson 将 json 字符串解析回 Java 对象，使输出更美观
                        row.put(md.getColumnName(i), gson.fromJson(((org.postgresql.util.PGobject) obj).getValue(), Object.class));
                    } else {
                        row.put(md.getColumnName(i), obj);
                    }
                }
                resultList.add(row);
            }
            return request.createResponseBuilder(HttpStatus.OK).header("Content-Type", "application/json").body(gson.toJson(resultList)).build();
        }
    }

    /**
     * 处理 HTTP POST 请求，用于创建一条新纪录。
     *
     * @param request 包含请求信息的 {@link HttpRequestMessage} 对象。
     * @param conn    一个活动的数据库连接。
     * @param table   操作的目标表名。
     * @param context Azure Function 的执行上下文。
     * @return 一个包含新记录 ID 的 HTTP 响应；如果验证失败，则返回 400 Bad Request。
     * @throws SQLException 如果发生数据库访问错误。
     */
    public HttpResponseMessage handlePost(HttpRequestMessage<Optional<String>> request, Connection conn, String table, ExecutionContext context) throws SQLException {
        String jsonBody = request.getBody().orElse(null);
        if (jsonBody == null || jsonBody.isEmpty()) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST).body("Request body is required for POST.").build();
        }

        JsonObject body = gson.fromJson(jsonBody, JsonObject.class);
        
        // 1. 从数据库获取表的元数据和主键
        Map<String, ColumnMetadata> tableColumns = DatabaseMetadataService.getTableColumns(conn, table, context);
        String primaryKeyColumn = DatabaseMetadataService.getPrimaryKeyColumnName(conn, table, context);

        if (primaryKeyColumn == null) {
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Table '" + table + "' does not have a primary key defined, cannot proceed.").build();
        }
        
        // 获取时间戳列名 
        String timestampColumn = findAutoTimestampColumn(tableColumns);

        // 2. 验证：检查所有非空字段是否都已提供
        List<String> missingFields = new ArrayList<>();
        for (Map.Entry<String, ColumnMetadata> entry : tableColumns.entrySet()) {
            String columnName = entry.getKey();

            // 如果一个列是 NOT NULL，它不是主键或者时间戳（我们会自己生成），并且请求体里也没有提供它
            if (!entry.getValue().isNullable() && !columnName.equals(primaryKeyColumn) && !columnName.equals(timestampColumn) && !body.has(columnName)) {
                missingFields.add(columnName);
            }
        }

        if (!missingFields.isEmpty()) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                    .body("Missing required fields: " + String.join(", ", missingFields)).build();
        }
        
        // 3. 准备构建 SQL
        List<String> columnsToInsert = new ArrayList<>();
        List<String> valuePlaceholders = new ArrayList<>();
        List<Object> params = new ArrayList<>();
        
        // 首先，添加由函数生成的 UUID 主键
        UUID newId = UUID.randomUUID();
        columnsToInsert.add(primaryKeyColumn);
        valuePlaceholders.add("?");
        params.add(newId);
        
        // 遍历请求体中的字段，只处理那些在数据库表中实际存在的列
        for (String key : body.keySet()) {
            if (key.equals(primaryKeyColumn) || key.equals(timestampColumn)) {
                continue;
            }
            if (tableColumns.containsKey(key)) {
                columnsToInsert.add(key);
                params.add(body.get(key)); 
                
                // 检查是否为jsonb类型
                ColumnMetadata meta = tableColumns.get(key);
                if ("jsonb".equalsIgnoreCase(meta.typeName())) {
                    valuePlaceholders.add("?::jsonb");
                } else {
                    valuePlaceholders.add("?");
                }
            }
        }

        // 添加由函数生成的时间戳
        handleAutoTimestampForInsert(tableColumns, columnsToInsert, valuePlaceholders);

        // 4. 构建 SQL 语句
        String sql = String.format("INSERT INTO %s (%s) VALUES (%s)",
                table,
                String.join(", ", columnsToInsert),
                String.join(", ", valuePlaceholders));
        
        context.getLogger().info("Executing POST: " + sql);
        
        // 5. 执行插入
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            for (int i = 0; i < params.size(); i++) {
                Object paramValue = params.get(i);
                if (paramValue instanceof UUID) {
                    pstmt.setObject(i + 1, paramValue);
                } else if (paramValue instanceof JsonElement) {
                    JsonElement value = (JsonElement) paramValue;
                     if (value.isJsonNull()) {
                        pstmt.setNull(i + 1, Types.VARCHAR);
                    } else if (value.isJsonObject() || value.isJsonArray()) {
                        pstmt.setString(i + 1, value.toString());
                    } else {
                        pstmt.setString(i + 1, value.getAsString());
                    }
                }
            }
            
            int affectedRows = pstmt.executeUpdate();
            
            if (affectedRows > 0) {
                 return request.createResponseBuilder(HttpStatus.CREATED)
                        .body("{\"id\": \"" + newId.toString() + "\", \"status\": \"created\"}")
                        .build();
            } else {
                return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                        .body("Failed to create record.").build();
            }
        }
    }

    /**
     * 处理 HTTP PATCH 请求，用于部分更新现有记录。
     *
     * @param request 包含请求信息的 {@link HttpRequestMessage} 对象。
     * @param conn    一个活动的数据库连接。
     * @param table   操作的目标表名。
     * @param context Azure Function 的执行上下文。
     * @return 一个包含受影响行数的 HTTP 响应；如果验证失败，则返回 400 Bad Request。
     * @throws SQLException 如果发生数据库访问错误。
     */
    public HttpResponseMessage handlePatch(HttpRequestMessage<Optional<String>> request, Connection conn, String table, ExecutionContext context) throws SQLException {
        String jsonBody = request.getBody().orElse(null);
        if (jsonBody == null || jsonBody.isEmpty()) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST).body("Request body is required for PATCH.").build();
        }
        
        Map<String, String> queryParams = request.getQueryParameters();
        if (queryParams.isEmpty()) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST).body("PATCH requests require query parameters for filtering (WHERE clause).").build();
        }

        // 1. 获取表的元数据
        Map<String, ColumnMetadata> tableColumns = DatabaseMetadataService.getTableColumns(conn, table, context);
        String primaryKeyColumn = DatabaseMetadataService.getPrimaryKeyColumnName(conn, table, context);

        JsonObject body = gson.fromJson(jsonBody, JsonObject.class);
        
        String timestampColumn = findAutoTimestampColumn(tableColumns);

        // 2. 构建 SET 子句
        List<String> setClauses = new ArrayList<>();
        List<Object> setParams = new ArrayList<>();
        for (String key : body.keySet()) {
            if (key.equals(primaryKeyColumn) || key.equals(timestampColumn)) {
                continue;
            }
            // 只处理在表中存在且不是主键的列
            if (tableColumns.containsKey(key) && !key.equals(primaryKeyColumn)) {
                JsonElement value = body.get(key);
                ColumnMetadata meta = tableColumns.get(key);

                if ("jsonb".equalsIgnoreCase(meta.typeName())) {
                    setClauses.add(key + " = ?::jsonb");
                } else {
                    setClauses.add(key + " = ?");
                }
                
                if (value.isJsonNull()) {
                    setParams.add(null);
                } else if (value.isJsonObject() || value.isJsonArray()) {
                    setParams.add(value.toString());
                } else {
                    setParams.add(value.getAsString());
                }
            }
        }

        handleAutoTimestampForUpdate(tableColumns, setClauses);
        
        if (setClauses.isEmpty()) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST).body("No valid columns to update were provided in the request body.").build();
        }
        
        // 3. 构建 WHERE 子句
        List<String> whereClauses = new ArrayList<>();
        List<Object> whereParams = new ArrayList<>();
        for (Map.Entry<String, String> entry : queryParams.entrySet()) {
            // 只处理在表中存在的列
            if (tableColumns.containsKey(entry.getKey())) {
                whereClauses.add(entry.getKey() + " = ?");
                try {
                    // 使用 UUID 转换尝试
                    whereParams.add(UUID.fromString(entry.getValue()));
                } catch (IllegalArgumentException e) {
                    whereParams.add(entry.getValue());
                }
            }
        }

        if (whereClauses.isEmpty()) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST).body("No valid query parameters provided for filtering.").build();
        }

        // 4. 合并参数并构建最终 SQL
        List<Object> allParams = new ArrayList<>(setParams);
        allParams.addAll(whereParams);

        String sql = String.format("UPDATE %s SET %s WHERE %s",
                table,
                String.join(", ", setClauses),
                String.join(" AND ", whereClauses));

        context.getLogger().info("Executing PATCH: " + sql);
        
        // 5. 执行更新
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            for (int i = 0; i < allParams.size(); i++) {
                pstmt.setObject(i + 1, allParams.get(i));
            }
            int affectedRows = pstmt.executeUpdate();
            return request.createResponseBuilder(HttpStatus.OK).body("{\"rowsAffected\": " + affectedRows + "}").build();
        }
    }
    
    /**
     * 处理 HTTP DELETE 请求，用于删除记录。
     *
     * @param request 包含请求信息的 {@link HttpRequestMessage} 对象。
     * @param conn    一个活动的数据库连接。
     * @param table   操作的目标表名。
     * @param context Azure Function 的执行上下文。
     * @return 一个包含受影响行数的 HTTP 响应；如果未提供过滤条件，则返回 400 Bad Request。
     * @throws SQLException 如果发生数据库访问错误。
     */
    public HttpResponseMessage handleDelete(HttpRequestMessage<Optional<String>> request, Connection conn, String table, ExecutionContext context) throws SQLException {
        Map<String, String> queryParams = request.getQueryParameters();
        if (queryParams.isEmpty()) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST).body("DELETE requests require query parameters for filtering. Unfiltered deletes are not allowed.").build();
        }

        // 1. 获取表的元数据用于验证
        Map<String, ColumnMetadata> tableColumns = DatabaseMetadataService.getTableColumns(conn, table, context);
        
        // 2. 构建 WHERE 子句
        List<String> whereClauses = new ArrayList<>();
        List<Object> params = new ArrayList<>();
        for (Map.Entry<String, String> entry : queryParams.entrySet()) {
            // 只处理在表中存在的列
            if (tableColumns.containsKey(entry.getKey())) {
                whereClauses.add(entry.getKey() + " = ?");
                try {
                    params.add(UUID.fromString(entry.getValue()));
                } catch (IllegalArgumentException e) {
                    params.add(entry.getValue());
                }
            }
        }
        
        if (whereClauses.isEmpty()) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST).body("No valid query parameters provided for filtering.").build();
        }

        // 3. 构建 SQL
        String sql = String.format("DELETE FROM %s WHERE %s",
                table,
                String.join(" AND ", whereClauses));

        context.getLogger().info("Executing DELETE: " + sql);
        
        // 4. 执行删除
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            for (int i = 0; i < params.size(); i++) {
                pstmt.setObject(i + 1, params.get(i));
            }
            int affectedRows = pstmt.executeUpdate();
            return request.createResponseBuilder(HttpStatus.OK).body("{\"rowsAffected\": " + affectedRows + "}").build();
        }
    }

    /**
     * 返回需要自动处理时间戳的列名
     * 注意：这里假设时间戳列的名称为 "upsert_date" 或 "updated_at"，后续需要改进。
     * 
     * @param tableColumns 当前表的元数据。
     * @return 时间戳列的名称，如果不存在则返回 null。
     */
    private String findAutoTimestampColumn(Map<String, ColumnMetadata> tableColumns) {
        if (tableColumns.containsKey("upsert_date")) {
            return "upsert_date";
        } else if (tableColumns.containsKey("updated_at")) {
            return "updated_at";
        }
        return null;
    }
    
    /**
     * 为 INSERT 操作处理自动时间戳。
     * 它会将时间戳列和 NOW() 函数添加到相应的列表中。
     * 
     * @param tableColumns 当前表的元数据。
     * @param columnsToInsert INSERT 语句的列名列表。
     * @param valuePlaceholders INSERT 语句的值占位符列表。
     */
    private void handleAutoTimestampForInsert(Map<String, ColumnMetadata> tableColumns, List<String> columnsToInsert, List<String> valuePlaceholders) {
        String timestampColumn = findAutoTimestampColumn(tableColumns);
        if (timestampColumn != null) {
            columnsToInsert.add(timestampColumn);
            valuePlaceholders.add("NOW()");
        }
    }
    
    
    /**
     * 为 UPDATE 操作处理自动时间戳。
     * 它会将 "column = NOW()" 添加到 SET 子句列表中。
     * 
     * @param tableColumns 当前表的元数据。
     * @param setClauses UPDATE 语句的 SET 子句列表。
     */
    private void handleAutoTimestampForUpdate(Map<String, ColumnMetadata> tableColumns, List<String> setClauses) {
        String timestampColumn = findAutoTimestampColumn(tableColumns);
        if (timestampColumn != null) {
            setClauses.add(timestampColumn + " = NOW()");
        }
    }
}

====================================
package com.yugabyte.function;

import com.microsoft.azure.functions.ExecutionContext;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 提供用于查询和缓存数据库元数据的服务。
 */
public class DatabaseMetadataService {

    /**
     * 缓存表的列元数据，以表名为键。
     */
    private static final Map<String, Map<String, ColumnMetadata>> tableMetadataCache = new ConcurrentHashMap<>();

    /**
     * 缓存表的主键列名，以表名为键。
     */
    private static final Map<String, String> primaryKeyCache = new ConcurrentHashMap<>();

    /**
     * 一个数据记录 (record)，用于封装关于单个数据库列的核心元数据。
     *
     * @param typeName   列的 SQL 类型名称 (例如 "varchar", "jsonb", "uuid")。
     * @param isNullable 如果列允许为 NULL，则为 true；否则为 false。
     */
    public record ColumnMetadata(String typeName, boolean isNullable) {}

    /**
     * 检查指定的表是否存在于数据库中。
     * 
     * @param conn       活动的数据库连接。
     * @param tableName  要检查的表的名称。
     * @param context    Azure Function 的执行上下文，用于日志记录。
     * @return 如果表存在，则返回 {@code true}；否则返回 {@code false}。
     * @throws SQLException 如果发生数据库访问错误。
     */
    public static boolean tableExists(Connection conn, String tableName, ExecutionContext context) throws SQLException {
        return !getTableColumns(conn, tableName, context).isEmpty();
    }

    /**
     * 使用数据库元数据动态获取并缓存指定表的主键列名。
     * 注意: 此方法假设表具有单列主键。
     *
     * @param conn       活动的数据库连接。
     * @param tableName  要查询的表的名称。
     * @param context    Azure Function 的执行上下文，用于日志记录。
     * @return 主键列的名称。如果表不存在或没有定义主键，则返回 {@code null}。
     * @throws SQLException 如果发生数据库访问错误。
     */
    public static String getPrimaryKeyColumnName(Connection conn, String tableName, ExecutionContext context) throws SQLException {
        if (primaryKeyCache.containsKey(tableName)) {
            return primaryKeyCache.get(tableName);
        }

        context.getLogger().info("Metadata Cache Miss: Querying primary key for table '" + tableName + "'.");
        DatabaseMetaData metaData = conn.getMetaData();
        try (ResultSet rs = metaData.getPrimaryKeys(null, null, tableName)) {
            if (rs.next()) {
                String pkColumnName = rs.getString("COLUMN_NAME");
                primaryKeyCache.put(tableName, pkColumnName);
                return pkColumnName;
            }
        }
        // 缓存 null 结果，以避免对没有主键的表进行重复查询
        primaryKeyCache.put(tableName, null);
        return null;
    }

    /**
     * 使用数据库元数据动态获取并缓存指定表的所有列及其属性。
     *
     * @param conn       活动的数据库连接。
     * @param tableName  要查询的表的名称。
     * @param context    Azure Function 的执行上下文，用于日志记录。
     * @return 一个 {@code Map<String, ColumnMetadata>}，其中键是列名，值是包含类型和可空性信息的 {@code ColumnMetadata} 对象。
     *         如果表不存在，则返回一个空 Map。
     * @throws SQLException 如果发生数据库访问错误。
     */
    public static Map<String, ColumnMetadata> getTableColumns(Connection conn, String tableName, ExecutionContext context) throws SQLException {
        if (tableMetadataCache.containsKey(tableName)) {
            return tableMetadataCache.get(tableName);
        }

        context.getLogger().info("Metadata Cache Miss: Querying columns for table '" + tableName + "'.");
        Map<String, ColumnMetadata> columnMap = new HashMap<>();
        DatabaseMetaData metaData = conn.getMetaData();
        try (ResultSet rs = metaData.getColumns(null, null, tableName, null)) {
            while (rs.next()) {
                String columnName = rs.getString("COLUMN_NAME");
                String typeName = rs.getString("TYPE_NAME");
                boolean isNullable = "YES".equalsIgnoreCase(rs.getString("IS_NULLABLE"));
                columnMap.put(columnName, new ColumnMetadata(typeName, isNullable));
            }
        }
        tableMetadataCache.put(tableName, columnMap);
        return columnMap;
    }
}

====================================
package com.yugabyte.function;

import com.microsoft.azure.functions.ExecutionContext;
import com.microsoft.azure.functions.HttpMethod;
import com.microsoft.azure.functions.HttpRequestMessage;
import com.microsoft.azure.functions.HttpResponseMessage;
import com.microsoft.azure.functions.HttpStatus;
import com.microsoft.azure.functions.annotation.AuthorizationLevel;
import com.microsoft.azure.functions.annotation.BindingName;
import com.microsoft.azure.functions.annotation.FunctionName;
import com.microsoft.azure.functions.annotation.HttpTrigger;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Optional;

/**
 * Azure Function 的主入口类。
 */
public class Function {

    private static final CrudHandler crudHandler = new CrudHandler();

    /**
     * Azure Function 的主执行方法。
     *
     * @param request 包含请求所有信息（如方法、查询参数、请求体）的对象。
     * @param table   从 URL 路径中动态捕获的表名。
     * @param context Azure Function 的执行上下文，用于访问日志记录器等运行时功能。
     * @return 对客户端的 HTTP 响应。
     */
    @FunctionName("YugaCrudApi")
    public HttpResponseMessage run(
            @HttpTrigger(
                name = "req",
                methods = {HttpMethod.GET, HttpMethod.POST, HttpMethod.PATCH, HttpMethod.DELETE},
                authLevel = AuthorizationLevel.ANONYMOUS,
                route = "{table}")
            HttpRequestMessage<Optional<String>> request,
            @BindingName("table") String table,
            final ExecutionContext context) {

        context.getLogger().info("Java HTTP trigger processed a " + request.getHttpMethod() + " request for table: " + table);

        // 从环境变量 (或 local.settings.json) 中获取数据库连接信息
        String url = System.getenv("DB_URL");
        String user = System.getenv("DB_USER");
        String password = System.getenv("DB_PASSWORD");

        try (Connection conn = DriverManager.getConnection(url, user, password)) {
            // 动态安全检查：在分派请求前，验证目标表是否存在于数据库中。
            if (!DatabaseMetadataService.tableExists(conn, table, context)) {
                return request.createResponseBuilder(HttpStatus.NOT_FOUND)
                        .body("Table '" + table + "' not found.").build();
            }

            // 根据 HTTP 方法，将请求和数据库连接委托给 CrudHandler 进行处理。
            switch (request.getHttpMethod()) {
                case GET:
                    return crudHandler.handleGet(request, conn, table, context);
                case POST:
                    return crudHandler.handlePost(request, conn, table, context);
                case PATCH:
                    return crudHandler.handlePatch(request, conn, table, context);
                case DELETE:
                    return crudHandler.handleDelete(request, conn, table, context);
                default:
                    // 对于 @HttpTrigger 中未列出的方法，返回错误。
                    return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                            .body("HTTP method not supported.").build();
            }
        } catch (SQLException e) {
            // 捕获所有 JDBC 和数据库相关的异常
            context.getLogger().severe("SQL Exception: " + e.getMessage());
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Database error occurred: " + e.getMessage()).build();
        } catch (Exception e) {
            // 捕获所有其他意外异常，防止敏感信息泄露
            context.getLogger().severe("Generic Exception: " + e.getMessage());
            return request.createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("An unexpected error occurred.").build();
        }
    }
}
